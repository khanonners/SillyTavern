import {
    animation_duration,
    callPopup,
    chat,
    cleanUpMessage,
    event_types,
    eventSource,
    Generate,
    getGeneratingApi,
    is_send_press,
    isStreamingEnabled,
    saveChatConditional,
    updateMessageBlock,
} from '../script.js';
import { debounce, delay, getStringHash, uuidv4 } from './utils.js';
import { decodeTextTokens, getTokenizerBestMatch } from './tokenizers.js';
import { power_user } from './power-user.js';

const TINTS = 4;
const MAX_MESSAGE_LOGPROBS = 100;

/**
 * Tuple of a candidate token and its logarithm of probability of being chosen
 * @typedef {[string, number]} Candidate - (token, logprob)
 */

/**
 * A node in the logprobs tree, representing a single generated message from
 * from the model and its logprob data.
 *
 * Elements without a parent are root nodes, representing the original message
 * (or swiped message) from which 'continue' gen was invoked.
 * @typedef {Object} LogprobsNode
 * @property {string} nodeId - unique ID
 * @property {string} [parent] - node ID of the parent LogprobsNode
 * @property {string[]} children - node IDs of child LogprobsNodes
 * @property {number} created - timestamp of when the node was created
 * @property {number} messageHash - hash of the source message
 * @property {TokenLogprobs[]} messageLogprobs - logprobs for each token
 * @property {string | null} continueFrom - the 'continue' prefix used to
 * generate the message, if any
 * @property {string | null} alternative - the selected alternative token
 */

/**
 * Logprob data for a single token
 * @typedef {Object} TokenLogprobs
 * @property {string} token - A token generated by the model
 * @property {Candidate[]} topLogprobs - Array of top candidate tokens
 */

let state = {
    /** @type {TokenLogprobs | null} */
    selectedTokenLogprobs: null,
    /** @type {Map<string, LogprobsNode>} */
    nodes: new Map(),
    /**
     * When we invoke a 'continue' completion, we create the node and hold it
     * here until the completion and logprobs data are received.
     * @type {LogprobsNode | null}
     */
    pendingNode: null,
    /** @type {string[]} */
    undoStack: [],
    ignoreEdit: false,
};

/**
 * renderAlternativeTokensView renders the Token Probabilities UI and all
 * subviews with the active message's logprobs data. If the message has no token
 * logprobs, a zero-state is rendered.
 */
function renderAlternativeTokensView() {
    const view = $('#logprobs_generation_output');
    if (state.pendingNode) {
        return;
    }
    view.empty();
    state.selectedTokenLogprobs = null;
    renderTopLogprobs();

    const { messageLogprobs, continueFrom } = findActiveLogprobsNode() || {};
    const usingSmoothStreaming = isStreamingEnabled() && power_user.smooth_streaming;
    if (!messageLogprobs?.length || usingSmoothStreaming) {
        const emptyState = $('<div></div>');
        const noTokensMsg = usingSmoothStreaming
            ? 'Token probabilities are not available when using Smooth Streaming.'
            : 'No token probabilities available for the current message.';
        const msg = power_user.request_token_probabilities
            ? noTokensMsg
            : '<span>Enable <b>Request token probabilities</b> in the User Settings menu to use this feature.</span>';
        emptyState.html(msg);
        emptyState.addClass('logprobs_empty_state');
        view.append(emptyState);
        return;
    }

    const prefix = continueFrom || '';
    const tokenSpans = [];

    if (prefix) {
        const prefixSpan = $('<span></span>');
        prefixSpan.text(prefix);
        prefixSpan.html(prefixSpan.html().replace(/\n/g, '<br>'));
        prefixSpan.addClass('logprobs_output_prefix');
        prefixSpan.attr('title', 'Select to reroll the last \'Continue\' generation');
        prefixSpan.click(onPrefixClicked);
        addKeyboardProps(prefixSpan);
        tokenSpans.push(...withVirtualWhitespace(prefix, prefixSpan));
    }

    messageLogprobs.forEach((tokenData, i) => {
        const { token } = tokenData;
        const span = $('<span></span>');
        const text = toVisibleWhitespace(token);
        span.text(text);
        span.addClass('logprobs_output_token');
        span.addClass('logprobs_tint_' + (i % TINTS));
        span.click(() => onSelectedTokenChanged(tokenData, span));
        addKeyboardProps(span);
        tokenSpans.push(...withVirtualWhitespace(token, span));
    });

    view.append(tokenSpans);

    renderContinuationsToolbar();

    // scroll past long prior context
    if (prefix) {
        const element = view.find('.logprobs_output_token').first();
        const scrollOffset = element.offset().top - element.parent().offset().top;
        element.parent().scrollTop(scrollOffset);
    }
}

function addKeyboardProps(element) {
    element.attr('role', 'button');
    element.attr('tabindex', '0');
    element.keydown(function (e) {
        if (e.key === 'Enter' || e.key === ' ') {
            element.click();
        }
    });
}

/**
 * renderTopLogprobs renders the top logprobs subview with the currently
 * selected token highlighted. If no token is selected, the subview is hidden.
 */
function renderTopLogprobs() {
    $('#logprobs_top_logprobs_hint').hide();
    const view = $('.logprobs_candidate_list');
    view.empty();

    if (!state.selectedTokenLogprobs) {
        return;
    }

    const { token: selectedToken, topLogprobs } = state.selectedTokenLogprobs;

    let sum = 0;
    const nodes = [];
    const candidates = topLogprobs
        .sort(([, logA], [, logB]) => logB - logA)
        .map(([text, log]) => {
            if (log <= 0) {
                const probability = Math.exp(log);
                sum += probability;
                return [text, probability, log];
            }
            else {
                return [text, log, null];
            }
        });
    candidates.push(['<others>', 1 - sum, 0]);

    let matched = false;
    for (const [token, probability, log] of candidates) {
        const container = $('<button class="flex-container flexFlowColumn logprobs_top_candidate"></button>');
        const tokenNormalized = String(token).replace(/^‚ñÅ/g, ' ');

        if (token === selectedToken || tokenNormalized === selectedToken) {
            matched = true;
            container.addClass('selected');
        }

        const tokenText = $('<span></span>').text(`${toVisibleWhitespace(token)}`);
        const percentText = $('<span></span>').text(`${(probability * 100).toFixed(2)}%`);
        container.append(tokenText, percentText);
        if (log) {
            container.attr('title', `logarithm: ${log}`);
        }
        addKeyboardProps(container);
        if (token !== '<others>') {
            container.click(() => onAlternativeClicked(state.selectedTokenLogprobs, token));
        } else {
            container.click(async () => {
                const custom = await callPopup('<h3>Custom continuation</h3><p>Continue from the selected token with custom text:</p>', 'input');
                if (custom) {
                    onAlternativeClicked(state.selectedTokenLogprobs, custom);
                }
            })
        }
        nodes.push(container);
    }

    // Highlight the <others> node if the selected token was not included in the
    // top logprobs
    if (!matched) {
        nodes[nodes.length - 1].css('background-color', 'rgba(255, 0, 0, 0.1)');
    }

    view.append(nodes);
}

/**
 * renderContinuationsToolbar renders the continuations toolbar subview for the
 * active message. If the message has no continuations, the subview is hidden.
 */
function renderContinuationsToolbar() {
    const view = $('#logprobs_continuations_toolbar').removeClass('hidden');
    // If we're in a continuation, we'll have a node ID on the active swipe.
    const { nodeId, parent: parentId } = findActiveLogprobsNode() || {};
    if (!getActiveSwipeInfo()?.extra?.logprobs_node_id) {
        return view.addClass('hidden');
    }

    const alternativesGroup = $('#logprobs_alternatives_group');
    const prevAlternative = alternativesGroup.find('#logprobs_prev_alternative').prop('disabled', true);
    const nextAlternative = alternativesGroup.find('#logprobs_next_alternative').prop('disabled', true);
    const counter = alternativesGroup.find('#logprobs_alternative_index');
    const historyGroup = $('#logprobs_history_group');
    const undo = historyGroup.find('#logprobs_undo').prop('disabled', true);
    const redo = historyGroup.find('#logprobs_redo').prop('disabled', true);

    if (state.undoStack.length) {
        redo.prop('disabled', false);
    }
    undo.off('click').click(() => {
        switchDisplayedMessage(parentId);
        state.undoStack.push(nodeId);
    });
    redo.off('click').click(() => {
        switchDisplayedMessage(state.undoStack.pop());
    });

    if (!parentId) {
        counter.text('1 / 1');
        return;
    } else {
        undo.prop('disabled', false);
    }

    const parentNode = state.nodes.get(parentId);
    const numAlternatives = parentNode.children.length;
    const indexWithinParent = parentNode.children.indexOf(nodeId);
    counter.text(`${indexWithinParent + 1} / ${numAlternatives}`);

    if (indexWithinParent !== 0) {
        prevAlternative.prop('disabled', false);
    }
    if (indexWithinParent !== numAlternatives - 1) {
        nextAlternative.prop('disabled', false);
    }
    prevAlternative.off('click').click(() => {
        switchDisplayedMessage(parentNode.children[indexWithinParent - 1]);
    });
    nextAlternative.off('click').click(() => {
        switchDisplayedMessage(parentNode.children[indexWithinParent + 1]);
    });
}

/**
 * onSelectedTokenChanged is called when the user clicks on a token in the
 * token output view. It updates the selected token state and re-renders the
 * top logprobs view, or deselects the token if it was already selected.
 * @param {TokenLogprobs} logprobs - logprob data for the selected token
 * @param {Element} span - target span node that was clicked
 */
function onSelectedTokenChanged(logprobs, span) {
    $('.logprobs_output_token.selected').removeClass('selected');
    if (state.selectedTokenLogprobs === logprobs) {
        state.selectedTokenLogprobs = null;
    } else {
        state.selectedTokenLogprobs = logprobs;
        $(span).addClass('selected');
    }
    renderTopLogprobs();
}

/**
 * onAlternativeClicked is called when the user clicks on an alternative token
 * in the top logprobs view. It will create a new swipe message and prefill it
 * with all text up to the selected token, followed by the chosen alternative.
 * Then it requests a `continue` completion from the model with the new prompt.
 * @param {TokenLogprobs} tokenLogprobs - logprob data for selected alternative
 * @param {string} alternative - selected alternative token's text
 */
function onAlternativeClicked(tokenLogprobs, alternative) {
    if (!checkGenerateReady()) {
        return;
    }

    if (getGeneratingApi() === 'openai') {
        return callPopup('<h3>Feature unavailable</h3><p>Due to API limitations, rerolling a token is not supported with OpenAI. Try switching to a different API.</p>', 'text');
    }

    const { messageLogprobs, continueFrom } = findActiveLogprobsNode();
    const replaceIndex = messageLogprobs.findIndex(x => x === tokenLogprobs);

    const tokens = messageLogprobs.slice(0, replaceIndex + 1).map(({ token }) => token);
    tokens[replaceIndex] = String(alternative).replace(/^‚ñÅ/g, ' ');

    const prefix = continueFrom || '';
    const prompt = prefix + tokens.join('');
    generateContinuation(prompt, alternative);
    state.selectedTokenLogprobs = null;
    renderTopLogprobs();
}

/**
 * onPrefixClicked is called when the user clicks on the carried-over prefix
 * in the token output view. It allows them to reroll the last 'continue'
 * completion with none of the output generated from it, in case they don't
 * like the results.
 */
function onPrefixClicked() {
    if (!checkGenerateReady()) {
        return;
    }

    const { continueFrom } = findActiveLogprobsNode();
    const prefix = continueFrom || '';
    generateContinuation(prefix);
    state.selectedTokenLogprobs = null;
    renderTopLogprobs();
}

function checkGenerateReady() {
    const isEditing = $('#mes_edit_buttons').is(':visible');
    if (is_send_press) {
        toastr.warning(`There is already an active generation in progress.`);
        return false;
    }
    if (isEditing) {
        toastr.warning(`Save or discard any active edits before continuing.`);
        return false;
    }
    return true;
}

/**
 * onToggleLogprobsPanel is called when the user performs an action that toggles
 * the logprobs view, such as clicking the Token Probabilities menu item or the
 * close button.
 */
function onToggleLogprobsPanel() {
    const logprobsViewer = $('#logprobsViewer');

    // largely copied from CFGScale toggle
    if (logprobsViewer.css('display') === 'none') {
        logprobsViewer.addClass('resizing');
        logprobsViewer.css('display', 'flex');
        logprobsViewer.css('opacity', 0.0);
        renderAlternativeTokensView();
        logprobsViewer.transition({
            opacity: 1.0,
            duration: animation_duration,
        }, async function () {
            await delay(50);
            logprobsViewer.removeClass('resizing');
        });
    } else {
        logprobsViewer.addClass('resizing');
        logprobsViewer.transition({
            opacity: 0.0,
            duration: animation_duration,
        },
        async function () {
            await delay(50);
            logprobsViewer.removeClass('resizing');
        });
        setTimeout(function () {
            logprobsViewer.hide();
        }, animation_duration);
    }
}

function switchDisplayedMessage(nodeId) {
    const node = state.nodes.get(nodeId);
    const msg = chat[chat.length - 1];

    const text = node.continueFrom + node.messageLogprobs.map(({ token }) => token).join('');
    msg.mes = cleanUpMessage(text, false, false);
    // There is also `substituteParams` but I have no idea what it does
    updateMessageBlock(chat.length - 1, msg);
    setNodeIdForSwipe(getActiveSwipeInfo(), nodeId);


    state.ignoreEdit = true;
    eventSource.once(event_types.MESSAGE_EDITED, () => state.ignoreEdit = false);
    eventSource.emit(event_types.MESSAGE_EDITED, msg).then(saveChatConditional).then(renderAlternativeTokensView);
}

/**
 * generateContinuation sends a 'continue' completion request to the model with
 * the given prompt and alternative token.  A new LogprobsNode will be created
 * for the pending completion and parented to the active message's LogprobsNode.
 * @param {string} prompt
 * @param {string} [alternative]
 */
function generateContinuation(prompt, alternative) {
    // Since our prompt was derived from raw tokens, it hasn't been cleaned up
    // the same way as existing message text. However `cleanUpMessage` might
    // remove the user's chosen alternative token (ie. trailing whitespace) so
    // we add it back if it's missing.
    let cleanedPrompt = cleanUpMessage(prompt, false, false);
    if (alternative && !cleanedPrompt.endsWith(alternative)) {
        cleanedPrompt += alternative;
    }

    let swipeInfo = getActiveSwipeInfo();
    state.pendingNode = createLogprobsNode({
        continueFrom: prompt,
        alternative,
    });

    // If the active swipe doesn't have a node ID, we'll create a new node for
    // it and make it the root of the tree.  Once the pending generation is
    // completed, it will immediately be added as a child of this node.
    if (!swipeInfo?.extra?.logprobs_node_id) {
        const { mes } = chat[chat.length - 1];
        const newNode = createLogprobsNode({ continueFrom: mes });
        state.nodes.set(newNode.nodeId, newNode);
        setNodeIdForSwipe(swipeInfo, newNode.nodeId);
        console.log('logprobs: created new root node for logprobs generation', newNode)
    }

    // If no alternative is provided, the user is rerolling is rerolling the
    // entire gen and this is a sibling. Otherwise, it's a child.
    const isSibling = !alternative
    const activeNode = state.nodes.get(swipeInfo.extra.logprobs_node_id);
    state.pendingNode.parent = isSibling ? activeNode.parent : activeNode.nodeId;

    const msg = chat[chat.length - 1];
    msg.swipes[msg.swipe_id] = cleanedPrompt;
    msg.mes = cleanedPrompt;
    updateMessageBlock(chat.length - 1, msg);

    console.log('logprobs: requesting continuation', state.pendingNode, prompt, alternative)
    Generate('continue').finally(() => state.pendingNode = null);
}

/**
 * toVisibleWhitespace receives input text and replaces spaces with &middot; and
 * newlines with ‚Üµ.
 * @param {string} input
 * @returns {string}
 */
function toVisibleWhitespace(input) {
    return input.replace(/ /g, '¬∑').replace(/‚ñÅ/g, '¬∑').replace(/\n/g, '‚Üµ');
}

/** @returns {{ send_date: number, gen_started: number, gen_finished: number, extra: any } | null} */
function getActiveSwipeInfo() {
    const msgId = chat.length - 1;
    if (!chat[msgId].swipe_info?.length) {
        return null;
    }
    return chat[msgId].swipe_info[chat[msgId].swipe_id];
}

function getMessageHash(message) {
    // We don't use the swipe ID as a hash component because it's not stable,
    // deleting a swipe will change the ID of all subsequent swipes.
    const hashParams = {
        name: message.name,
        mid: chat.indexOf(message),
        text: message.mes,
    };
    return getStringHash(JSON.stringify(hashParams));
}

/**
 * findActiveLogprobsNode returns the LogprobsNode associated with the active
 * message. If there are no logprobs for the active message, it returns null.
 * @returns {LogprobsNode | null}
 */
function findActiveLogprobsNode() {
    // First look for the node ID on the active swipe
    const swipeInfo = getActiveSwipeInfo();
    const nodeId = swipeInfo?.extra?.logprobs_node_id;
    const node = state.nodes.get(nodeId);

    if (nodeId && !node) {
        // Node expired or app was reloaded, clear the persisted node ID
        delete swipeInfo.extra.logprobs_node_id;
    } else if (node) {
        return node;
    }

    // If there's no node ID saved to the swipe, or there are no swipes, then
    // look for a root node with a matching message hash.
    const hash = getMessageHash(chat[chat.length - 1]);
    for (const node of state.nodes.values()) {
        if (!node.parent && node.messageHash === hash) {
            return node;
        }
    }
    return null;
}

/**
 * createLogprobsNode returns a new LogprobsNode with the given parent and
 * continuation prefix, without adding it to the logprobs tree.
 * @param {string} [parent] - id of the parent node, if any
 * @param {string} [continueFrom] - continuation prefix, if any
 * @param {string} [alternative] - selected alternative token, if any
 * @returns {LogprobsNode}
 */
export function createLogprobsNode({ parent, continueFrom, alternative }) {
    return {
        nodeId: uuidv4(),
        parent,
        children: [],
        created: new Date().getTime(),
        messageHash: 0,
        messageLogprobs: [],
        continueFrom,
        alternative,
    };
}

/**
 * setNodeIdForSwipe sets the given LogprobsNode ID on the given swipe info's
 * extras field, allowing it to be identified as the parent of a continuation.
 * @param {object} swipeInfo - the swipe info object to modify
 * @param {string} nodeId - the logprobs node ID to associate with the swipe
 */
function setNodeIdForSwipe(swipeInfo, nodeId) {
    // Value is made non-enumerable to prevent it from being copied to new
    // swipes or saved to disk.
    Object.defineProperty(swipeInfo.extra, 'logprobs_node_id', {
        value: nodeId,
        enumerable: false,
        configurable: true,
    });
}

/**
 * saveLogprobsForActiveMessage receives an array of TokenLogprobs objects
 * representing the top logprobs for each token in a message and associates it
 * with the active message.
 *
 * **Ensure the active message has been updated and rendered before calling
 * this function or the logprobs data will be saved to the wrong message.**
 * @param {TokenLogprobs[]} logprobs - array of logprobs data for each token
 * @param {string | null} continueFrom  - for 'continue' generations, the prompt
 */
export function saveLogprobsForActiveMessage(logprobs, continueFrom) {
    if (!logprobs) {
        // non-streaming APIs could return null data
        return;
    }

    convertTokenIdLogprobsToText(logprobs);

    let node;
    const swipeInfo = getActiveSwipeInfo();
    if (state.pendingNode) {
        // Generation was triggered by the logprobs UI.

        node = state.pendingNode;
        state.pendingNode = null;

        const parentId = node.parent;
        if (parentId) {
            const parentNode = state.nodes.get(parentId);
            parentNode.children.push(node.nodeId);
        }

        // Associate the new continuation node with the active swipe
        setNodeIdForSwipe(swipeInfo, node.nodeId);
        console.log('logprobs: added new child node for logprobs generation', node)
    } else if (swipeInfo?.extra?.logprobs_node_id) {
        // Generation not triggered by the logprobs UI, but is on a swipe with
        // previous logprobs data, so we'll add it to the tree as a child.
        node = createLogprobsNode({ parent: swipeInfo.extra.logprobs_node_id, continueFrom });
        const parentNode = state.nodes.get(node.parent);
        parentNode.children.push(node.nodeId);
        console.log('logprobs: added new child node for external generation', node)
    } else {
        // Generation not triggered by the logprobs UI, and has no previous
        // logprobs data.
        node = createLogprobsNode({ continueFrom });
        setNodeIdForSwipe(swipeInfo, node.nodeId);
        console.log('logprobs: created new root node', node)
    }

    // Set message data for the node and add it to the logprobs map
    node.messageHash = getMessageHash(chat[chat.length - 1]);
    node.messageLogprobs = logprobs;
    state.nodes.set(node.nodeId, node);

    // Clean up old logprobs data
    const oldLogprobs = Array.from(state.nodes.values())
        .sort((a, b) => b.created - a.created)
        .slice(MAX_MESSAGE_LOGPROBS);
    for (const oldData of oldLogprobs) {
        state.nodes.delete(oldData.id);
    }

    renderAlternativeTokensView();
}

/**
 * convertLogprobTokenIdsToText mutates the given logprobs data's topLogprobs
 * field keyed by token text instead of token ID. This is only necessary for
 * APIs which only return token IDs in their logprobs data; for others this
 * function is a no-op.
 * @param {TokenLogprobs[]} input - logprobs data with numeric token IDs
 */
function convertTokenIdLogprobsToText(input) {
    const api = getGeneratingApi();
    if (api !== 'novel') {
        return input;
    }

    const tokenizerId = getTokenizerBestMatch(api);

    // Flatten unique token IDs across all logprobs
    const tokenIds = Array.from(new Set(input.flatMap(logprobs =>
        logprobs.topLogprobs.map(([token]) => token).concat(logprobs.token),
    )));

    // Submit token IDs to tokenizer to get token text, then build ID->text map
    const { chunks } = decodeTextTokens(tokenizerId, tokenIds);
    const tokenIdText = new Map(tokenIds.map((id, i) => [id, chunks[i]]));

    // Fixup logprobs data with token text
    input.forEach(logprobs => {
        logprobs.token = tokenIdText.get(logprobs.token);
        logprobs.topLogprobs = logprobs.topLogprobs.map(([token, logprob]) =>
            [tokenIdText.get(token), logprob],
        );
    });
}

/**
 * withVirtualWhitespace inserts line breaks and a zero-width space before and
 * after the span node if its token begins or ends with whitespace in order to
 * allow text to wrap despite whitespace characters being replaced with a dot.
 * @param {string} text - token text being evaluated for whitespace
 * @param {Element} span - target span node to be wrapped
 * @returns {Element[]} array of nodes to be appended to the DOM
 */
function withVirtualWhitespace(text, span) {
    const result = [span];
    if (text.match(/^\s/)) {
        result.unshift(document.createTextNode('\u200b'));
    }
    if (text.match(/\s$/)) {
        result.push($(document.createTextNode('\u200b')));
    }
    if (text.match(/^‚ñÅ/)) {
        result.unshift(document.createTextNode('\u200b'));
    }
    // line breaks are trickier. we don't currently handle consecutive line
    // breaks or line breaks occuring in between non-whitespace characters, but
    // tokenizers generally don't produce those anyway.

    // matches leading line break, at least one character, and trailing line break
    if (text.match(/^\n(?:.|\n)+\n$/)) {
        result.unshift($('<br>'));
        result.push($('<br>'));
    } else if (text.match(/^\n/)) {
        result.unshift($('<br>'));
    } else if (text.match(/\n$/)) {
        result.push($('<br>'));
    }
    return result;
}

function handleEditedMessage() {
    if (state.ignoreEdit) {
        return;
    }

    // Once a message has been edited, the logprobs data for it is no longer
    // valid. If it was a continuation (has a parent) we'll create a new child
    // that has only `continueFrom` set to the new message text.  If it's a
    // root node the hash will no longer match so we can just re-render.
    const msg = chat[chat.length - 1];
    const swipeInfo = getActiveSwipeInfo();
    const parent = swipeInfo?.extra?.logprobs_node_id;
    const currentHash = getMessageHash(msg);
    const previousHash = findActiveLogprobsNode()?.messageHash;

    if (parent && currentHash !== previousHash) {
        const node = createLogprobsNode({ parent, continueFrom: msg.mes });
        /** @type {Candidate} */
        node.messageLogprobs = [{ token: '', topLogprobs: [] }];
        setNodeIdForSwipe(swipeInfo, node.nodeId);
        state.nodes.set(node.nodeId, node);
        console.log('logprobs: created new child node for edited message', node);
    }

    renderAlternativeTokensView();
}

export function initLogprobs() {
    const debouncedRender = debounce(() => {
        state.undoStack = [];
        renderAlternativeTokensView();
    });
    $('#logprobsViewerClose').click(event => {
        event.preventDefault();
        onToggleLogprobsPanel();
    });
    $('#option_toggle_logprobs').click(onToggleLogprobsPanel);
    // invoke collapse on the logprobs panel if the user clicks the header text
    // $('.logprobs_panel_header').click((event) => {
    //     const buttonId = event.target.id;
    //     if (buttonId !== 'logprobsViewerCollapse') {
    //         return;
    //     }
    //     $('#logprobsViewerCollapse').click();
    // });
    eventSource.on(event_types.CHAT_CHANGED, debouncedRender);
    eventSource.on(event_types.CHARACTER_MESSAGE_RENDERED, debouncedRender);
    eventSource.on(event_types.IMPERSONATE_READY, debouncedRender);
    eventSource.on(event_types.MESSAGE_DELETED, debouncedRender);
    eventSource.on(event_types.MESSAGE_EDITED, handleEditedMessage);
    eventSource.on(event_types.MESSAGE_SWIPED, debouncedRender);
}
